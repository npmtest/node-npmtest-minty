{"/home/travis/build/npmtest/node-npmtest-minty/test.js":"/* istanbul instrument in package npmtest_minty */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minty/lib.npmtest_minty.js":"/* istanbul instrument in package npmtest_minty */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_minty = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_minty = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-minty/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-minty && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_minty */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_minty\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_minty.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_minty.rollup.js'] =\n            local.assetsDict['/assets.npmtest_minty.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_minty.__dirname +\n                    '/lib.npmtest_minty.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/index.js":"const parser = require('./lib/parser.js').parser;\nconst fs = require('fs');\nconst ruler = require('./lib/createLineRules.js').ruler;\nconst inject = require('./lib/injector.js');\nconst run = require('./lib/run.js');\nconst anonFunc = require('./lib/tools.js').anonFuncCheck;\nconst minty = {};\n\n\n/**\n* reads the file the user provides, creates an abstract syntax tree, creates rules, injects monitoring code based on rules, generates HTML file for user\n* @param {string} absolute path to file that will be analyze\n**/\n\nfunction file(path) {\n  const JSTEXT = fs.readFileSync(path).toString();\n  const parsed = parser(JSTEXT);\n  const rules = ruler(parsed);\n  const injected = inject(rules, JSTEXT);\n  run.runFile(injected, path, JSTEXT);\n  return;\n}\n\n/**\n* turns function to a string, turns function into abstract syntax tree, creates rules to inject monitoring code, and returns function that will output HTML file each time it is called\n* @param {function}\n* @returns {function} each time returned function is executed, an HTML visualization will be created\n**/\nfunction wrap(func) {\n  const JSTEXT = func.toString();\n  const namedJsFunc = anonFunc(JSTEXT);\n  const parsed = parser(namedJsFunc);\n  const rules = ruler(parsed);\n  const injected = inject(rules, namedJsFunc);\n  const mintified = run.wrap(injected, namedJsFunc);\n  return function() {\n    const args = Array.prototype.slice.call(arguments);\n    return mintified.apply(null, args);\n  };\n}\n\nminty.file = file;\nminty.wrap = wrap;\n\n\nmodule.exports = minty;\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/lib/parser.js":"'use strict';\n\nconst esprima = require('esprima');\nconst esquery = require('esquery');\nconst parseutils = {};\n// const fs = require('fs');\n\nparseutils.cache = {};\nparseutils.tokens = [];\n\nlet ast;\n\n/**\n * function to parse through ast and return desired information based off search parameter\n * @param {string} string - search term, i.e. '[attr=\"foo\"]'\n * @param {object} AST - AST that will be searched. Did not call param 'ast' as\n *              that variable has been used already\n * @returns {array} - array of matching AST nodes, each of which is an Object\n **/\nparseutils.query = function (string, AST) {\n  const parseInformation = esquery.parse(string);\n  return esquery.match(AST, parseInformation);\n};\n\n/**\n* function parses ast and finds all function declarations, adding parameters\n* @param {object} node - an AST node, representing a function, whose parameters we want to grab\n* @returns {array} - function parameters\n**/\nparseutils.functionParameterParse = function (node) {\n  return node.params.map(paramsObj => paramsObj.name);\n};\n\n/**\n* function parses ast and finds all function declarations, adding names\n* @param {object} node - an AST node, representing a function, whose name we want to grab\n* @returns {string} - function name\n**/\nparseutils.functionNameParse = function (node) {\n  return node.id.name;\n};\n\n/**\n* function parses ast and finds all variable declarations, determining how they were declared (let, var, const)\n* @param {object} node - an AST node, representing a varable, whose declaration we want to grab\n* @returns {string} - variable declaration of let, var, or const\n**/\nparseutils.variableKindParse = function (node) {\n  return node.kind;\n};\n\n/**\n* function parses ast and finds all variable names\n* @param {object} node - an AST node, representing a variable, whose name we want to grab\n* @returns {string} - variable name\n**/\nparseutils.variableNameParse = function (node) {\n  return node.declarations.map(dec => dec.id.name);\n};\nconst types = [\n  { type: 'BreakStatement', callbacks: null },\n  { type: 'ReturnStatement', callbacks: null },\n  { type: 'YieldExpression', callbacks: null },\n  {\n    type: 'FunctionDeclaration',\n    callbacks: [[parseutils.functionParameterParse, 'parameters'],\n      [parseutils.functionNameParse, 'name']],\n  },\n  {\n    type: 'FunctionExpression',\n    callbacks: [[parseutils.functionParameterParse, 'parameters']],\n  },\n  {\n    type: 'ArrowFunctionExpression',\n    callbacks: [[parseutils.functionParameterParse, 'parameters']],\n  },\n  { type: 'SwitchCase', callbacks: null },\n  {\n    type: 'VariableDeclaration',\n    callbacks: [[parseutils.variableKindParse, 'kind'],\n      [parseutils.variableNameParse, 'variables']],\n  },\n  { type: 'CallExpression', callbacks: null },\n  { type: 'SwitchStatement', callbacks: null },\n  { type: 'ForStatement', callbacks: null },\n  { type: 'ForInStatement', callbacks: null },\n  { type: 'ForOfStatement', callbacks: null },\n  { type: 'WhileStatement', callbacks: null },\n  { type: 'DoWhileStatement', callbacks: null },\n  { type: 'IfStatement', callbacks: null },\n];\n\n\n/**\n* function parses ast and finds all global variables not declared with let, var, or const\n* @param {object} node - an AST node, representing a program, whose globals we want to grab\n* @deprecated since 0.1.5, force 'use strict';\n* @returns {string} - variable name\n**/\n// parseutils.assignmentExpParse = function (node) {\n//   return node.left.name;\n// };\n\n/**\n* Object contains all of the AST node types we parse. To add a new node type:\n* @param {string} type - selector for the node type. See https://www.npmjs.com/package/esquery.\n* @param {array} callbacks - an array of callbacks, containing the following:\n* @param {array} - A single array containing a single callback, with\n* @param (function} - the callback function to run, in the 0th index of the array\n* @param {string} - the key in which you want to store the callback's return, in the 1st index of the array)\n*/\n/**\n * function parses ast and finds all searchString nodes, runs callbacks after\n * @param searchString - finds all nodes with this string via esquery\n * @param callbacks - array with nested arrays [[function, logName], ...], logs extra parameters\n **/\nparseutils.parseFunction = function (searchString, callbacks) {\n  if (!parseutils.cache[searchString]) {\n    parseutils.cache[searchString] = [];\n  }\n\n  const output = parseutils.query(`[type=${searchString}]`, ast);\n\n  // Tempting to use map and concat but seems like push is faster\n  //  http://jsperf.com/multi-array-concat/7\n  output.forEach(node => {\n    parseutils.cache[searchString].push({\n      startLine: node.loc.start.line,\n      endLine: node.loc.end.line,\n    });\n    if (callbacks) {\n      callbacks.forEach(cbArray => {\n        const name = cbArray[1];\n        const func = cbArray[0];\n        const extraOutput = func(node);\n        parseutils.cache[searchString][parseutils.cache[searchString].length - 1][name]\n          = extraOutput;\n      });\n    }\n  });\n};\n\n/**\n* function loops through the types object and returns an array of callbacks to be run, when the AST is parsed\n**/\nparseutils.asyncTasks = types.map(function (el) {\n  return parseutils.parseFunction.bind(this, el.type, (el.callbacks || null));\n});\n\n/**\n* function parses a Javascript file and returns an object containing interesting nodes and their details,\n* by looping through it with the {@link #parseutils.asyncTasks} array\n* @param {string} text - the text of the file to analyze\n* @returns {object} - cache object\n**/\nfunction parser(text) {\n  parseutils.cache = {};\n\n  ast = esprima.parse(text, {\n    loc: true,\n  });\n\n  parseutils.asyncTasks.forEach(func => {\n    func();\n  });\n  return parseutils.cache;\n}\n\nmodule.exports = {\n  parser,\n  parseutils,\n  types,\n};\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/lib/createLineRules.js":"'use strict';\n\nlet lineRules = {\n  ruler,\n  addVariables,\n  addLines,\n  addScopeName,\n};\n\n/**\n* building up the lineActivity object - keys are line numbers and values are objects- looks like { rulesFound: [ { action: 'START or END', rule: 'SCOPE', type: 'SwitchCase' } ] }\n* @param {type of statement/expression/function declaration} type\n* @param {a string like 'swap', 'void' - it avoids inserting monitoring code in objects, multi-line function call, 'scope'} rule\n* @param {the parsed data we got from the abstract syntax tree for each of the type (ForStatement, FunctionDeclaration, ArrowFunctionExpression, SwitchCase, VariableDeclaration, etc) - an array of objects that has the start and end lines for each of the types. if its a var declaration will also have kind and variables as properties.\nexample:\n[{ startLine: 3,\n    endLine: 3,\n    kind: 'var',\n    variables: [ 'one', 'two', 'three' ] },\n    { startLine: 4,\n    endLine: 4,\n    kind: 'var',\n    variables: [ 'four', 'five' ] }]\n } cluster\n\n* lineActivity is globally defined - thats why we can add properties to the lineActivity object that we defined in ruler\n**/\n\n// start line is group.startline - 1 because when we read the text, we are splitting the lines of text by \\n and so now its an array\nfunction addLines(type, rule, cluster, lineActivity) {\n  let startLine;\n  let endLine;\n  cluster.forEach(group => {\n    startLine = group.startLine - 1;\n    endLine = group.endLine - 1;\n    if (!lineActivity[startLine]) lineActivity[startLine] = {};\n    if (!lineActivity[startLine].rulesFound) lineActivity[startLine].rulesFound = [];\n    if (rule) {\n      lineActivity[startLine].rulesFound.push({ action: 'START', rule, type });\n    }\n    if (!lineActivity[endLine]) lineActivity[endLine] = {};\n    if (!lineActivity[endLine].rulesFound) lineActivity[endLine].rulesFound = [];\n    if (rule) {\n      lineActivity[endLine].rulesFound.push({ action: 'END', rule, type });\n    }\n  });\n}\n\n/**\n* addVariables is adding more properties to the nested objects in the lineActivity objects\n* checking if any element(the element is an object) in the cluster array are parameters for a function - if there are we are adding a key called parameters to line.variable\n*if there are variables then we are adding a name and kind key called variables to the line.variables object\n**/\n\nfunction addVariables(cluster, lineActivity) {\n  cluster.forEach(group => {\n    const line = lineActivity[group.startLine - 1];\n    if (!line.variables) line.variables = {};\n    if (group.parameters) {\n      line.variables.parameters = group.parameters;\n    }\n    if (group.variables) {\n      line.variables.variables = {\n        names: group.variables,\n        kind: group.kind,\n      };\n    }\n  });\n\n}\n\n/**\n  @param {the parsed data we got from the abstract syntax tree for each of the type (ForStatement, FunctionDeclaration, ArrowFunctionExpression, SwitchCase, VariableDeclaration, etc) - an array of objects that has the start and end lines for each of the types. if its a var declaration will also have kind and variables as properties.\n  example:\n  [{ startLine: 3,\n      endLine: 3,\n      kind: 'var',\n      variables: [ 'one', 'two', 'three' ] },\n      { startLine: 4,\n      endLine: 4,\n      kind: 'var',\n      variables: [ 'four', 'five' ] }]\n   } cluster\n\n**/\n\n/* function declaration - this will have a name so the function name will be set to line.SCOPE\n function expression - var func = function() {} this function doesnt have a name, but we are getting the variable name and setting that as its scope name\n*/\nfunction addScopeName(cluster, lineActivity) {\n\n  cluster.forEach(group => {\n    const line = lineActivity[group.startLine - 1];\n    if (group.name) {\n      line.scope = group.name;\n    } else if (group.parameters) {\n      if (line.variables.variables) {\n        line.scope = line.variables.variables.names.join('');\n      } else {\n        line.scope = 'anonymous function';\n      }\n    }\n  });\n}\n\n//examples of call expression users.find, console.log, invoking function\nfunction ruler(parsed) {\n  let lineActivity = {};\n  Object.keys(parsed).forEach(type => {\n    switch (type) {\n      case 'BreakStatement':\n      case 'ReturnStatement':\n      case 'YieldExpression':\n        lineRules.addLines(type, 'SWAP', parsed[type], lineActivity);\n        break;\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n      case 'ArrowFunctionExpression':\n      case 'SwitchCase':\n        lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);\n        lineRules.addVariables(parsed[type], lineActivity);\n        lineRules.addScopeName(parsed[type], lineActivity);\n        break;\n      case 'VariableDeclaration':\n        lineRules.addLines(type, null, parsed[type], lineActivity);\n        lineRules.addVariables(parsed[type], lineActivity);\n        break;\n      case 'CallExpression':\n      case 'SwitchStatement':\n        lineRules.addLines(type, 'VOID', parsed[type], lineActivity);\n        break;\n      default:\n        lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);\n        break;\n    }\n  });\n  return lineActivity;\n}\n\nmodule.exports = lineRules;\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/lib/injector.js":"'use strict';\n\nconst decomment = require('decomment');\nconst injectionLog = {};\nconst flattenDeep = require('./tools').flattenDeep;\nlet scope;\nlet injectCheck;\nlet specialVariablesLog;\nlet specialVariables;\nlet variables;\n\n/**\n* Function finds the scope of an object describing the current line of code\n* If it creates a new scope, then it adds an array of the current level to the {@link #specialVariables} object\n* If it closes a scope, then it pops the last array off of the {@link #specialVariables} object\n\n* going through all the lines of code and corresponding rules\n* if there is rule called scope we push the scope name to the scope array to keep track of scopes\n* some lines of code wont have rules because we only care about if something is being declared - so if something like\n* var a = 0, b = 1, x = 5;\n* a = b + x wont have rule because a is just being reassigned a new value. so it'll just getting monitoring code injected after it\n* we loop over the rulesfound array which an array of object(s). the object looks like { action: 'START or END', rule: 'SCOPE', type: 'SwitchCase' }\n* if there is a rule called scope and start action, we'll check if lineInfo has a property called scope - if it does we know its some sort of block statement\nif there is a block scope we push an empty array into the special variables array\n* @param {object} lineInfo - the rules we created for the line of code being analyzed\n* @event #specialVariables .push() or .pop()\n* @returns {undefined} - undefined - this builds an external value\n**/\n\nfunction findScope(lineInfo) {\n  if (!lineInfo) return;\n  lineInfo.rulesFound.forEach(rule => {\n    // if there is scope, we are creating a new array for it in case there are variables declared inside the block statement\n    if (rule.rule === 'SCOPE' && rule.action === 'START') {\n      if (lineInfo.scope) {\n        scope.push(lineInfo.scope);\n      } else {\n        scope.push('');\n      }\n      specialVariables.push([]);\n    }\n    // if the rule is scope, then we get rid of the last thing in the special variables array like a stack\n    if (rule.rule === 'SCOPE' && rule.action === 'END') {\n      scope.pop();\n      specialVariables.pop();\n    }\n  });\n}\n\n/**\n* Function looks at an object describing a line of Javascript\n* and adds the variables found there to the scope within which that line executes\n* some lines of code dont have rules because all we care about are things being declared. so assignment expressions dont need rules\n* this function is being called right after findscope so if there are parameters in the current lineInfo those parameters\n* gets added to the special variables array\n* scope is an array that keeps track of what scope were in. it will always have mintyglobalscope as 0th index\n* if there are global variables we'll be adding them to the variables array\n* if there are global variables but scoped, they are added to the special variables array\n* @param {object} lineInfo - the rules associated with the line of code being analyzed\n* @event add variables to {@link #specialVariables}\n* @event add variables to {@link #variables}\n* @returns {undefined} - undefined - this builds an external value\n**/\nfunction addVars(lineInfo) {\n  if (!lineInfo || !lineInfo.variables) return;\n  const line = lineInfo.variables;\n  const lastIdx = specialVariables.length - 1;\n  if (line.parameters) {\n    specialVariables[lastIdx] =\n      specialVariables[lastIdx].concat(line.parameters);\n  }\n  if (line.variables) {\n    let currentScope;\n    scope.forEach(block => {\n      if (block) currentScope = block;\n    });\n    if (line.variables.kind === 'var' && currentScope === '_mintyGlobalScope') {\n      variables = variables.concat(line.variables.names);\n    } else {\n      specialVariables[lastIdx] =\n        specialVariables[lastIdx].concat(line.variables.names);\n    }\n  }\n}\n\n/**\n* Function looks at an object describing a line of Javascript\n* and reviews if it has triggered rules that end a scope.\n* If it has triggered those rules, then it updates the {@link #injectCheck} array\n* to add a flag to inject watching code; remove a flag; or flag to not inject\n* @param {object} lineInfo - the line of code being analyzed\n* @event add true or false, or pop the last item from, {@link #specialVariables}\n* @returns {undefined} - undefined - this builds an external value\n**/\nfunction checkClosingLine(lineInfo, lineText) {\n  if (lineInfo) {\n    lineInfo.rulesFound.forEach(rule => {\n      if (rule.action === 'START' && rule.rule === 'VOID') injectCheck.push(false);\n      else if (rule.action === 'START' && rule.rule === 'SCOPE') {\n        injectCheck.push(true);\n      } else if (rule.action === 'END' && (rule.rule === 'VOID' || rule.rule === 'SCOPE')) {\n        injectCheck.pop();\n      }\n    });\n    // checking if a line is closing brace\n    return lineText.trim() === lineText.trim().replace(/[A-Za-z0-9]/g, '');\n  }\n  return undefined;\n}\n\n/**\n* Function looks at a line, evaluates it against rules, and sees if it contains global variables\n* inject check at last index has a value true or false\n* specialVariables is the array of nested arrays keeping track of scoped variables - arrays have values of the variables names in them\n* specialVariablesLog - adding the vaiebls\n* @param {object} lineRules - rules created for each corresponding line of code user provides '25':\n   { rulesFound: [ [Object] ],\n     variables: { variables: [Object], parameters: [Object] },\n     scope: 'ted' },\n* @param {string} line - the line of code\n* @param {number} index - the 0-based line number, index of the array when findGlobalVars is called\n* @event trigger {@link #findScope} on the lineRules\n* @event trigger {@link #addVars} on the lineRules\n* @event add the special (local to this block) variables to the {@link #specialVariablesLog}\n* @returns {undefined} - undefined - this builds an external value\n**/\nfunction findGlobalVars(lineRules, line, index) {\n  if (injectCheck[injectCheck.length - 1]) {\n    findScope(lineRules);\n    addVars(lineRules);\n    if (specialVariables[0].length >= 1 || specialVariables.length > 1) {\n      // slice makes shallow copy of specialVariables array - specialVariables is constantly changing - if we dont use shallow copy, in the end\n      specialVariablesLog[index] = specialVariables.slice(0);\n    }\n  }\n}\n/**\n* Function injects monitoring code into appropriate lines of the source JS\n* @param {array} log - Running log of original code + injected code.\n* @param {string} line - the original line of code\n* @param {number} index - the 0-based line number\n* @param {boolean} check - a flag to prevent or allow injection - true false\n* @param {object} lineRules - an object of rules, variables names, scope that define where the monitoring code should be injected - values for rulesfound property: [SWAP, START, VOID, SCOPE],\n* @param {number} closingLine - the 1-based line number on which the statement closes\n* @event trigger adds line to the {@link #log} variable which will be turned back into a file and executed\n* @returns {true, false or undefined} - undefined - this builds an external value\n**/\nfunction injector(log, line, index, check, lineRules, closingLine) {\n  let returnStatement = false;\n  let preVoidStatement = false;\n  let lineSpecial;\n  let globalVariables;\n  let mintyLine;\n  let lineCheck = check;\n  let callExpressionAndCallback;\n\n  if (specialVariablesLog[index] && specialVariablesLog[index].length) {\n    lineSpecial = specialVariablesLog[index];\n  } else {\n    lineSpecial = undefined;\n  }\n  if (variables.length) {\n    globalVariables = variables;\n  } else {\n    globalVariables = undefined;\n  }\n\n  mintyLine = `mintyLog(${index}, '${JSON.stringify(scope)}',`\n    + `${JSON.stringify(lineSpecial)}, ${JSON.stringify(variables)}`;\n\n  if (lineSpecial) {\n    const flatSpecial = flattenDeep(lineSpecial);\n    if (flatSpecial.length) mintyLine += `,${flattenDeep(lineSpecial)}`;\n  }\n\n  if (globalVariables) {\n    mintyLine += `, ${variables}`;\n  }\n\n\n  mintyLine += ');';\n  if (lineRules) {\n    lineRules.rulesFound.forEach(rule => {\n      if (rule.rule === 'SWAP' && rule.action === 'START') {\n        returnStatement = true;\n      }\n      if (rule.rule === 'VOID' && rule.action === 'START') {\n        preVoidStatement = true;\n        lineCheck = true;\n      }\n      if (rule.rule === 'SCOPE' && rule.action === 'START') {\n        callExpressionAndCallback = true;\n      }\n    });\n  }\n  if ((!lineCheck || closingLine || line === '') && !returnStatement) {\n    log.push(`${line}`);\n  } else if (preVoidStatement && callExpressionAndCallback) {\n    log.push(`${line}`, mintyLine);\n  } else if (returnStatement) {\n    log.push(mintyLine, `${line}`, mintyLine);\n  } else if (preVoidStatement) {\n    log.push(mintyLine, `${line}`);\n  } else {\n    log.push(`${line}`, mintyLine);\n  }\n}\n\n/**\n* Function parses the given text with the given rules\n* special variables start out with a nested empty array\n* parsing code for all the global variables in the first foreach call\n* @param {line activity object we built up in createLineRules.js} rules - The rules the code should be parsed with\n* @param {string} text - the original code\n* @returns {array} - an array of all of the lines of code, with the necessary\n*                    injection code as well, for later execution\n**/\nfunction injectionEngine(rules, text) {\n  injectionLog.log = [];\n  injectionLog.globalVars = [];\n  scope = ['_mintyGlobalScope'];\n  injectCheck = [true];\n  specialVariablesLog = {};\n  specialVariables = [[]];\n  variables = [];\n  // EOL = End of Line - the correct line carriage: \\n for Unix and \\r\\n for Windows\n  const EOL = decomment.getEOL(text);\n  // textArray is the user's code but formatted as an array - each line is an index of the array\n  const textArray = decomment(text, {\n    space: true,\n  })\n    .split(EOL);\n\n  textArray.forEach((line, i) => {\n    if (line !== '') {\n      // passing in each line of code and its corresponding rule, and the index\n      // some rules will be undefined bc some lines are empty\n      findGlobalVars(rules[i], line, i);\n    }\n  });\n  textArray.forEach((line, i) => {\n    // closingLine will have value true false or undefined\n    const closingLine = checkClosingLine(rules[i], line);\n    findScope(rules[i]);\n    addVars(rules[i]);\n    injector(injectionLog.log, line, i, injectCheck[injectCheck.length - 1], rules[i], closingLine);\n  });\n  injectionLog.globalVars = variables;\n  return injectionLog;\n}\n\n\nmodule.exports = injectionEngine;\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/lib/tools.js":"'use strict';\n\nconst tools = {};\n\ntools.flattenDeep = function flattenDeep(array) {\n  if (array) {\n    let flattenArray = [];\n    for (let i = 0; i < array.length; i++) {\n      const element = array[i];\n      if (element.constructor === Array) {\n        flattenArray = flattenArray.concat(flattenDeep(element));\n      } else {\n        flattenArray.push(element);\n      }\n    }\n    return flattenArray;\n  }\n  return undefined;\n};\n\n\ntools.anonFuncCheck = function anonFuncCheck(jsText) {\n  if (jsText[9] === '(') {\n    const namedAnonFunc = jsText.replace(jsText[8], ' anonymousFunc');\n    return namedAnonFunc;\n  }\n  return jsText;\n};\n\nmodule.exports = tools;\n","/home/travis/build/npmtest/node-npmtest-minty/node_modules/minty/lib/run.js":"'use strict';\n\nconst _eval = require('eval');\nconst fs = require('fs');\nconst appRoot = require('app-root-path');\nconst stringify = require('json-stringify-safe');\n\nlet filename;\nlet log;\n\n\nfunction mintyLog(lineNumber, scope, special, variables) {\n  const args = Array.prototype.slice.call(arguments, 4);\n  const retObj = {\n    file: filename,\n    line: lineNumber,\n    variables: {\n      special: {},\n      global: {},\n    },\n    scope,\n  };\n  function variableAdd(type, key) {\n    const array = type;\n    if (key === 'special') {\n      for (const el in type) {\n        retObj.variables[key][el] = {};\n        type[el].forEach(val => {\n          retObj.variables[key][el][val] = JSON.stringify(args[0]);\n          args.splice(0, 1);\n        });\n      }\n    } else {\n      while (array.length) {\n        retObj.variables[key][array[0]] = JSON.stringify(args[0]);\n        args.splice(0, 1);\n        array.splice(0, 1);\n      }\n    }\n  }\n\n  variableAdd(special, 'special');\n  variableAdd(variables, 'global');\n  // return object into results array\n  return log.push(retObj);\n}\n\nfunction errorLineFind(text, finalLog) {\n  let finalLine = 0;\n  if (finalLog.length) {\n    finalLine = finalLog[finalLog.length - 1].line;\n  }\n  const errInfo = {};\n  let completed = false;\n  text.log.forEach(line => {\n    if (completed) return;\n    if (line.indexOf('mintyLog') !== -1) {\n      const currLine = parseInt(line.slice(9), 10);\n      if (currLine > finalLine) {\n        errInfo.line = currLine;\n        errInfo.scope = line.split(',')[1];\n        completed = true;\n      }\n    }\n  });\n  return errInfo;\n}\n\nfunction finalizeOutput(outputObj) {\n  return stringify(outputObj, (key, value) => {\n    if (value === undefined) return '_mintyUndefined';\n    if (value === Function) return value.toString();\n    return value;\n  });\n}\n\n\nfunction finalizeRun(output, type) {\n  const name = filename;\n  const date = new Date();\n  fs.mkdir(appRoot + '/minty', () => {\n    fs.mkdir(appRoot + `/minty/${type}`, () => {\n      const jquery = fs.readFileSync(appRoot + '/node_modules/jquery/dist/jquery.min.js');\n      const normalizeCss = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/skeleton/css/normalize.css');\n      const skeletonCss = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/skeleton/css/skeleton.css');\n      const template = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/mintyVisTemplate.js');\n      const beginningHtml = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/beginning.html');\n      const endHtml = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/end.html');\n      const bodyHtml = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/body.html');\n      const viz = fs.readFileSync(appRoot + '/node_modules/minty/lib/mintyTemplates/viz.js');\n      const insert = `${beginningHtml} \\n <script type=\"text/javascript\"> \\n ${jquery} \\n </script> \\n <style>`\n        + `\\n ${normalizeCss} \\n </style> \\n <style> \\n ${skeletonCss} \\n </style> \\n ${bodyHtml} \\n`\n        + `<script>${viz}</script>\\n`\n        + `<script type=\"text/javascript\"> \\n var data = ${output} \\n ${template} \\n </script> \\n ${endHtml}`;\n      fs.writeFile(appRoot + `/minty/${type}/${name}_${date.toString().replace(/\\s+/gm, '_').replace(/:+/gm, '-')}.html`, insert, (err3) => {\n        if (err3) console.log(err3);\n      });\n    });\n  });\n}\n\nfunction errorHandler(error, text) {\n  const errInfo = errorLineFind(text, log);\n  const errVars = log.length ? log[log.length - 2].variables : text.globalVars;\n  log.push({\n    file: filename,\n    line: errInfo.line,\n    scope: JSON.stringify([errInfo.scope]),\n    error: error.message,\n    variables: errVars,\n  });\n}\n\nfunction runFile(fileText, absPath, originalText) {\n  const fileJS = fileText.log.join('\\n');\n  log = [];\n  filename = absPath.slice(absPath.lastIndexOf('/') + 1);\n  try {\n    _eval(fileJS, filename, {\n      mintyLog: mintyLog,\n    }, true);\n  } catch (err) {\n    console.log(`\\n\\n#################################################################################\\nMinty has found an error! Please check the out put of ${filename} for more details\\n#################################################################################\\n`);\n    errorHandler(err, fileText);\n  } finally {\n    const output = {\n      entry: filename,\n      log: log,\n    };\n    output[filename] = originalText;\n    const fileOutput = finalizeOutput(output);\n    finalizeRun(fileOutput, 'file');\n    console.log(`Minty has finished analyzing ${filename}`);\n  }\n}\n\nfunction wrap(wrapText, originalText) {\n  let returnStatement;\n  log = [];\n  filename = wrapText.log[1]\n    .split(',')[2]\n    .replace(/\\s+|\\]|\\'|\\\"/g, '');\n  const wrapJS = wrapText.log.join('\\n');\n  return function() {\n    const args = Array.prototype.slice.call(arguments);\n    try {\n      const fn = eval(`(${wrapJS})`);\n      returnStatement = fn.apply(null, args);\n    } catch (err) {\n      console.log(`\\n\\n#################################################################################\\nMinty has found an error! Please check the out put of ${filename} for more details\\n#################################################################################\\n`);\n      errorHandler(err, wrapText);\n    } finally {\n      const output = {\n        entry: filename,\n        log: log,\n      };\n      output[filename] = originalText;\n      const wrapOutput = finalizeOutput(output);\n      finalizeRun(wrapOutput, 'function');\n    }\n    return returnStatement;\n  };\n}\n\n\nconst run = {\n  runFile: runFile,\n  wrap: wrap,\n};\n\nmodule.exports = run;\n"}